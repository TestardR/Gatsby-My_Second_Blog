---
title: What is a monolithic application ?
date: '2020-09-05'
time: '☕️'
template: 'post'
draft: false
slug: 'Arch-7'
category: 'Architecture'
description: "Let's take a look at monolith as an archicture design with Romana Gnatyk"
socialImage: '/media/mono_architecture.png'
---

This article was done using my notes from [Romana Gnatyk](https://www.n-ix.com/microservices-vs-monolith-which-architecture-best-choice-your-business/) (2018).

<sub>Romana Gnatyk. (2018). "Microservices vs Monolith: which architecture is the best choice for your business?
". N-iX</sub>

## Monolith as an architecture design

A monolithic application is built as a single and indivisible unit. Usually, such a design is made up of a client-side user interface, a server side-application, and a database.

As Romana Gnatyk explains, monolithic applications have one large code base. As such, they lack modularity in the sense as it is not divided among several repositories.

If developers want to update or change something, they access the same code base. So, they make changes in the whole stack at once.

![monolithic architecture](/media/mono_architecture.png)

## Strengths and weaknesses

Here is a useful list of nicely picked strengths and weaknesses by Romana Gnatyk.

### Strengths

#### 1. Less cross-cutting concerns

Cross-cutting concerns affect the whole application (such as logging, handling, caching, and performance monitoring). In a monolithic application, this area of functionality concerns only one application so it is easier to handle it.

#### 2. Easier debugging and testing

Since a monolithic app is a single indivisible unit, you can run end-to-end testing much faster.

#### 3. Easy to deploy

When it comes to monolithic applications, you do not have to handle many deployments – just one file or directory.

#### 4. Easy to develop

Monolithic applications as an architecture pattern is easy to grasp and straightforward to implement.

### Weaknesses

### 1. Understanding

When a monolithic application scales up, it becomes too complicated to understand. Also, a complex system of code within one application is hard to manage.

### 2. Making changes

It is harder to implement changes in such a large and complex application with highly tight coupling. Any code change affects the whole system so it has to be thoroughly coordinated. This makes the overall development process much longer.

### 3. Scalability

You cannot scale components independently, only the whole application.

### 4. New technology barriers

It is extremely problematic to apply a new technology in a monolithic application because then the entire application may have to be rewritten.